/*
Паттерн "фасад" (dacade) применяют:
- когда необходимо предоставить простой интерфейс для сложной системы
- когда необходимо объединить различные компоненты системы в единый интерфейс
- когда клиенты не должны зависеть от внутренней структуры компонентов

Плюсы:
- упрощение использования сложной системы
- снижение зависимостей
Минусы:
- ограничение гибкости
- возможное увеличение объема кода

Примеры использования:
- фасад может предоставлять простой интерфейс для работы с графическими элементами, скрывая сложности отрисовки и управления ресурсами
- если ваше приложение взаимодействует с несколькими внешними сервисами, фасад может предоставлять API для взаимодействия с ними
- фасад может предоставлять упрощенный интерфейс для выполнения основных операций с базой данных, скрывая подробности запросов и управления транзакциями
*/

package pattern
import "fmt"

// EngineSubsystem подсистема двигателя
type EngineSubsystem struct{}

func (e *EngineSubsystem) start() {
	fmt.Println("Двигатель запущен")
}

// ACSubsystem подсистема кондиционера
type ACSubsystem struct{}

func (ac *ACSubsystem) turnOn() {
	fmt.Println("Кондиционер включен")
}

// CarFacade фасад для работы с автомобилем
type CarFacade struct {
	engine *EngineSubsystem
	ac     *ACSubsystem
}

// NewCarFacade создает новый экземпляр CarFacade
func NewCarFacade() *CarFacade {
	return &CarFacade{
		engine: &EngineSubsystem{},
		ac:     &ACSubsystem{},
	}
}

// StartCar запускает автомобиль с использованием фасада
func (c *CarFacade) StartCar() {
	fmt.Println("Подготовка к поездке:")
	c.engine.start()
	c.ac.turnOn()
	fmt.Println("Автомобиль готов к движению")
}

func main() {
	// Создаем фасад
	carFacade := pattern.NewCarFacade()

	// Используем фасад для запуска автомобиля
	carFacade.StartCar()
}
